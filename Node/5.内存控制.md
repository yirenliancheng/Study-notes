# 内存控制

## V8的内存限制

##### Node使用内存的限制：

* 64位操作系统：1.4GB
* 32位操作系统：0.7GB

##### 原因：

Node是基于V8构建的，V8是给浏览器使用的。

##### 调整内存限制的方法：

在Node启动的时候设置`--max-old-space-size`或`--max-new-space-size`来限制内存的大小

```js
//老生代内存空间配置
node --max-old-space-size = 1700 test.js  //单位为MB 
//或者
//新生代内存空间配置
node --max-new-space-size = 1024 test.js  //单位为KB
```

## V8的垃圾回收机制

V8的垃圾回收策略主要基于分代式垃圾回收机制。内存分为**新生代**和**老生代**两代。

### V8主要的垃圾回收算法

#### Scavenge算法

将堆内存分为**Form空间**（使用中的空间）和**To空间**（闲置的空间）。

##### 原理：

1. 检查Form空间中的存活对象复制到To空间，释放掉非存活对象。

2. Form空间和To空间对换（翻转）
3. 存活周期长的对象移动到老生代中。（对象晋升）

##### 缺点：

只能使用堆内存的一半。

#### Mark-Sweep & Mark-Compact

Mark-Sweep：标记清除

##### 缺点：（内存碎片）

在进行依次标记清除回收后，内存空间会出现不连续的状态。如果后续需要分配大内存的对象，碎片空间无法满足要求，会提前触发垃圾回收，这次回收是非必要的。

Mark-Compact：标记整理

可以解决标记清除方式的内存碎片的问题。

对象非存活之后，会将活着的对象往一端移动，移动完成之后，直接清理掉边界外的内存。

#### Incremental Marking

前面三种垃圾收集算法需要将应用逻辑暂停下来，是一种**全停顿**的方式。

为了降低垃圾回收带来的停顿时间。

采用**增量标记**的方式：垃圾回收与逻辑交替执行直到标记阶段完成。

### 查看垃圾回收日志

在启动的时候添加以下参数：

* `--trace_gc`

​       得到垃圾回收信息

* `--prof`

​      得到V8执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间。

V8提供了linux-tick-processor工具用于统计日志信息。可以从Node源码的`deps/v8/tools`目录下找到。

## 内存泄漏

Node对内存泄漏十分敏感。

##### 实质：

应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。

##### 原因：

* 缓存
* 队列消费不及时
* 作用域未释放

### 内存泄漏的排查

有很多工具可以用于定位Node应用的内存泄漏。

##### 常见工具：

* node-heapdump

```js
//安装node-heapdump
npm install heapdump
//引入代码
var headdump = require('heapdump')
```

* node-memwatch
  1. stats事件

​            每次进行全堆垃圾回收时，将会触发一次stats事件，这个事件将会传递内存的统计信息。

* 2. leak事件

​            连续5次垃圾回收后，内存仍然没有被释放，则出现了**内存泄漏**，触发leak事件。

* 3. 堆内存比较

​            通过抓取快照和比较快照的功能，能够比较堆上对象的名称和分配数量，找出内存泄漏的元凶。

